#!/usr/bin/env python2

import sys
import argparse
import urllib
from routeParser import getElevations, saveElevation, parseKML
import string

def main():
    """Reads the file whose name is specified as a command-line argument.
    Parses the line which has a '%%%' flag at the beginning of a line.  
    generates an elevation profile and a header for jekyll to read will be 
    generated.  Write the preprocessed file to the _posts directory with the 
    filename taken from the title and date keys of the parsed dictionary.""" 
 
    def vPrint(string):
        if args.verbose:
            print(string)
       
    DESC="KML processing tool to visualize saved route data"
    p = argparse.ArgumentParser(description=DESC)

    p.add_argument('filename', type=str,
                   nargs=1, help='the post to be processed')
    p.add_argument('-v', '--verbose', action ='store_true', dest='verbose',
                   help='enables verbose output')
    p.add_argument('-r', '--regraph', action ='store_true', dest='regraph',
                   help='regenerate graphs from cached ele data')
    
    args = p.parse_args()

    filename = args.filename[0]
    try:
        infile = open(filename, 'r')
        lines = infile.readlines()
        infile.close()
    except:                                  
        print("Could not open file: %s" % filename)
        sys.exit(1)
    
    parselines = [line for line in lines if line[:3] == '%%%']
    assert len(parselines) == 1
    line = parselines[0]

    vPrint("Parsing line.")
    argsDict = parseLine(line)

    eleDataFilename = "eleData/" + argsDict['date'] + ".txt"
    elePngFilename = "images/eleprof/"+ argsDict['date'] + ".png"
    argsDict.update({'elefilename': elePngFilename,
                     'eleURL': '/' + elePngFilename})

    paths = argsDict['paths']
    size  = argsDict['size']

    vPrint("Generating elevation profile.")

    if args.regraph:
        elevations = getCachedEleData(eleDataFilename)
    else:
        elevations = getElevations(paths, samples=250)
        vPrint("Caching elevation results.")
        cacheEleData(eleDataFilename, elevations)

    vPrint("Saving elevation profile.")
    saveElevation(elePngFilename, elevations, size)
    
    # Get the text other than the preprocessed line
    lines.remove(line)
    content = string.join(lines, '')

    vPrint("Generating header for jekyll.")
    header = makeHeader(**argsDict)
    
    outString = header + content
        
    outFileName = "_posts/%s-%s.md" % \
                   (argsDict['date'],argsDict['title'])
    outFileName = outFileName.replace(' ','')

    vPrint("Writing output file.")
    outfile = open(outFileName, 'w')
    outfile.write(outString)
    outfile.close()

def makeHeader(**kwargs):
    """Make the header which jekyll will read to generate the page."""
    return '---\n' +\
           'layout: log\n' +\
           'title: %s\n' % kwargs['title'] +\
           'author: %s\n' % kwargs['author'] +\
           'category: daily\n' +\
           'mapURL: "%s"\n' % kwargs['mapURL'] +\
           'eleURL: "%s"\n' % kwargs['eleURL'] +\
           '---\n\n'

def parseLine(line):
    """Parse the line by removing the first three characters, evaling the line,
    which hopefully will eval to a dictionary, getting the kml from the from
    the url, parsing that into paths and loading that into the returned
    dictionary."""

    line = line[3:]
    argsDict = eval(line)

    # There are a few things which need to be specified.
    if not argsDict.has_key('size'):
        print("size specification is mandatory")
        sys.exit(1)
    if not argsDict.has_key('date'):
        print("date specification is mandatory")
        sys.exit(1)
    if not argsDict.has_key('title'):
        print("title specification is mandatory")
        sys.exit(1)
    if not argsDict.has_key('mapURL'):
        print("mapURL specification is mandatory")
        sys.exit(1)
    if not argsDict.has_key('author'):
        print("author specification is mandatory")
        sys.exit(1)

    kml = getKML(argsDict['mapURL'])
    paths = parseKML(kml)
    argsDict.update({'paths': paths})
    return argsDict

def getKML(url):
    """Open the url and get return a string which hopefully contains some
    KML."""
    
    kmlfile = urllib.urlopen(url)
    kml = kmlfile.read()
    return kml

def getCachedEleData(filename):
    from numpy import genfromtxt
    return genfromtxt(filename)

def cacheEleData(filename, eleData):
    with open(filename, 'w') as f:
        for pt in eleData:
            f.write(str(pt) + '\n')

if __name__ == '__main__':
    main()

